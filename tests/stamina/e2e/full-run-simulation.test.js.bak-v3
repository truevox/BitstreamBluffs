/**
 * E2E tests for stamina system over a full game run
 */
import { measurePerformance, mockMathRandom, createPhaserSceneMock } from '../../test-utils.js';
import { jest, describe, test, expect } from '@jest/globals';


// Mock dependencies
jest.mock('../../../js/config/physics-config.js', () => ({ ({
  stamina: {
    max: 100,
    min: 0,
    surfaces: {
      snow: { drainRate: 0.2 },
      ice: { drainRate: 0.1 },
      powder: { drainRate: 0.4 }
    },
    items: {
      smallEnergy: { regenAmount: 15 },
      mediumEnergy: { regenAmount: 30 },
      largeEnergy: { regenAmount: 50 }
    },
    baseRegenRate: 0.05,
    speedDrainMultiplier: 0.02,
    criticalThreshold: 20
  },
  terrain: {
    minSlopeAngle: 10,
    maxSlopeAngle: 45,
    smoothingFactor: 0.85,
    variationFrequency: 0.2
  },
  player: {
    landingSafetyAngle: 30,
    safeLandingSpeedThreshold: 10,
    crashSpeedThreshold: 18
  },
  movement: {
    maxSpeed: 15,
    acceleration: 0.2,
    brakeStrength: 0.4,
    airBrakeStrength: 0.15
  },
  trick: {
    scoreBase: 100,
    comboMultiplier: 1.5
  }
}));

// Get the mocked modules
const PhysicsConfig = jest.requireMock('../../../js/config/physics-config.js');


/**
 * Comprehensive game simulation for E2E testing of the stamina system
 */
class GameRunner {
  constructor(seed = 42) {
    this.seed = seed;
    this.resetRandom = mockMathRandom(seed);
    
    // Time tracking
    this.totalTime = 0;
    this.frameTime = 16.67; // ~60fps
    
    // Player state
    this.player = {
      position: { x: 0, y: 500 },
      velocity: { x: 3, y: 0 },
      onGround: true,
      crashed: false,
      stamina: 100,
      staminaDrainPaused: false,
      speedMultiplier: 1.0
    };
    
    // Trick system
    this.tricks = {
      score: 0,
      combo: 0,
      flips: 0
    };
    
    // Energy items
    this.energyItems = [];
    
    // Generate terrain
    this.terrain = this.generateTerrain(100);
    
    // Record history for analysis
    this.stateHistory = [];
    
    // Input queue for automated actions
    this.scheduledInputs = [];
  }
  
  generateTerrain(segmentCount) {
    const segments = [];
    let lastY = 500;
    const segmentWidth = 100;
    
    for (let i = 0; i < segmentCount; i++) {
      // Generate variation using randomness
      const variation = (Math.random() * 2 - 1) * 0.2;
      const smoothingFactor = 0.85;
      
      // Calculate next Y with smoothing
      let nextY = lastY + (variation * 150);
      nextY = lastY + ((nextY - lastY) * smoothingFactor);
      
      // Ensure within bounds
      nextY = Math.max(300, Math.min(700, nextY));
      
      // Determine surface type based on terrain properties
      let surfaceType = 'snow'; // Default
      
      // Different surfaces based on segment position or angle
      if (i % 5 === 0) {
        surfaceType = 'ice'; // Every 5th segment is ice
      } else if (i % 7 === 0) {
        surfaceType = 'powder'; // Every 7th segment is powder
      }
      
      // Add jump ramps occasionally
      let type = 'normal';
      if (i % 10 === 9) {
        type = 'jump';
        nextY -= 50; // Make a gap
      }
      
      segments.push({
        startX: i * segmentWidth,
        startY: lastY,
        endX: (i + 1) * segmentWidth,
        endY: nextY,
        surfaceType,
        type
      });
      
      lastY = nextY;
      
      // Occasionally spawn energy items 
      if (i % 15 === 7 || i % 23 === 12) {
        const itemX = i * segmentWidth + Math.random() * segmentWidth;
        const itemY = lastY - 30; // Above terrain
        
        const itemTypes = ['smallEnergy', 'mediumEnergy', 'largeEnergy'];
        const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
        
        this.energyItems.push({
          type: itemType,
          position: { x: itemX, y: itemY },
          collected: false
        });
      }
    }
    
    return segments;
  }
  
  getTerrainSegmentAtPosition(x) {
    for (const segment of this.terrain) {
      if (x >= segment.startX && x < segment.endX) {
        return segment;
      }
    }
    return null;
  }
  
  checkItemCollisions() {
    // Check for item collisions
    const collisionRadius = 30;
    
    for (const item of this.energyItems) {
      if (!item.collected) {
        const dx = this.player.position.x - item.position.x;
        const dy = this.player.position.y - item.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < collisionRadius) {
          // Collect the item
          item.collected = true;
          
          // Apply stamina regeneration
          this.collectEnergyItem(item.type);
        }
      }
    }
  }
  
  collectEnergyItem(type) {
    
    const regenAmount = PhysicsConfig.stamina.items[type]?.regenAmount || 0;
    
    if (regenAmount > 0) {
      this.player.stamina = Math.min(
        PhysicsConfig.stamina.max,
        this.player.stamina + regenAmount
      );
      
      // Also pause stamina drain briefly after collecting an item
      this.player.staminaDrainPaused = true;
      setTimeout(() => {
        this.player.staminaDrainPaused = false;
      }, 1000);
    }
  }
  
  updateStamina(deltaTime) {
    
    
    // Skip stamina update if drain is paused (after item collection)
    if (this.player.staminaDrainPaused) return;
    
    const segment = this.getTerrainSegmentAtPosition(this.player.position.x);
    
    if (segment && this.player.onGround && !this.player.crashed) {
      // Get surface drain rate
      const drainRate = PhysicsConfig.stamina.surfaces[segment.surfaceType]?.drainRate || 
                        PhysicsConfig.stamina.surfaces.snow.drainRate;
      
      // Speed-based additional drain
      const speedDrain = Math.abs(this.player.velocity.x) * PhysicsConfig.stamina.speedDrainMultiplier;
      
      // Total drain for this frame
      const totalDrain = (drainRate + speedDrain) * deltaTime;
      
      // Update stamina
      this.player.stamina = Math.max(PhysicsConfig.stamina.min, this.player.stamina - totalDrain);
      
      // Check for critical stamina
      if (this.player.stamina <= PhysicsConfig.stamina.criticalThreshold) {
        // In critical state, speed is reduced
        this.player.speedMultiplier = 0.7;
      } else {
        // Normal speed multiplier
        this.player.speedMultiplier = 1.0;
      }
    } else if (!this.player.onGround) {
      // In air, use a different calculation or no drain
      // For this test, we'll use a minimal air drain
      const airDrain = 0.05 * deltaTime;
      this.player.stamina = Math.max(PhysicsConfig.stamina.min, this.player.stamina - airDrain);
    }
  }
  
  checkTerrainCollision() {
    const segment = this.getTerrainSegmentAtPosition(this.player.position.x);
    if (!segment) return false;
    
    // Calculate terrain height at player x position
    const segmentProgress = (this.player.position.x - segment.startX) / (segment.endX - segment.startX);
    const terrainY = segment.startY + (segment.endY - segment.startY) * segmentProgress;
    
    // Check if player is below (or at) terrain height
    if (this.player.position.y >= terrainY) {
      if (!this.player.onGround) {
        this.handleLanding(segment);
      }
      
      // Snap to terrain
      this.player.position.y = terrainY;
      this.player.onGround = true;
      return true;
    } else {
      // Above terrain
      if (this.player.onGround) {
        this.handleTakeoff();
      }
      return false;
    }
  }
  
  handleLanding(segment) {
    
    
    // Get landing parameters
    const { landingSafetyAngle, safeLandingSpeedThreshold, crashSpeedThreshold } = PhysicsConfig.player;
    
    // Calculate landing metrics
    const landingSpeed = Math.abs(this.player.velocity.y);
    const landingAngle = Math.abs(segment.angle);
    const isAngleSafe = landingAngle <= landingSafetyAngle;
    const isSpeedSafe = landingSpeed <= safeLandingSpeedThreshold;
    const isCrashing = landingSpeed > crashSpeedThreshold || !isAngleSafe;
    
    // Handle landing outcome
    if (isCrashing) {
      this.player.crashed = true;
      this.player.velocity.x *= 0.2; // Slow down significantly on crash
      
      // Crashing also drains stamina
      this.player.stamina = Math.max(0, this.player.stamina - 15);
      
      // Schedule recovery from crash
      this.scheduleInput(2000, { action: 'recoverFromCrash' });
    } else if (!isSpeedSafe && isAngleSafe) {
      this.player.velocity.x *= 0.7; // Slow down a bit
    }
    
    // Cancel vertical velocity on landing
    this.player.velocity.y = 0;
  }
  
  handleTakeoff() {
    this.player.onGround = false;
  }
  
  recoverFromCrash() {
    if (this.player.crashed) {
      this.player.crashed = false;
      this.player.velocity.x = 2; // Restart with some minimal speed
    }
  }
  
  scheduleInput(delay, input) {
    this.scheduledInputs.push({
      time: this.totalTime + delay,
      input
    });
  }
  
  processScheduledInputs() {
    const currentTime = this.totalTime;
    
    // Process any scheduled inputs that are due
    const dueInputs = this.scheduledInputs.filter(item => item.time <= currentTime);
    this.scheduledInputs = this.scheduledInputs.filter(item => item.time > currentTime);
    
    // Apply each due input
    for (const { input } of dueInputs) {
      if (input.action === 'recoverFromCrash') {
        this.recoverFromCrash();
      } else if (input.action === 'boost') {
        this.player.velocity.x += 2;
      } else if (input.action === 'jump') {
        if (this.player.onGround) {
          this.player.velocity.y = -8;
          this.player.onGround = false;
        }
      }
    }
  }
  
  updatePhysics(deltaTime) {
    // Skip if crashed
    if (this.player.crashed) {
      // Even if crashed, process scheduled inputs (for recovery)
      this.processScheduledInputs();
      return;
    }
    
    // Apply gravity if in air
    if (!this.player.onGround) {
      this.player.velocity.y += 15 * deltaTime;
    }
    
    // Apply slope force if on ground
    if (this.player.onGround) {
      const segment = this.getTerrainSegmentAtPosition(this.player.position.x);
      if (segment) {
        const slopeAngleRad = segment.angle * (Math.PI / 180);
        const slopeForce = Math.sin(slopeAngleRad) * 10;
        this.player.velocity.x += slopeForce * deltaTime;
        
        // Apply appropriate friction based on surface type
        
        const friction = PhysicsConfig.stamina.surfaces[segment.surfaceType]?.drainRate || 
                        PhysicsConfig.stamina.surfaces.snow.drainRate;
        
        // Convert friction to a physical force
        const frictionForce = friction * Math.abs(this.player.velocity.x) * 2;
        const direction = Math.sign(this.player.velocity.x);
        
        if (Math.abs(this.player.velocity.x) > frictionForce) {
          this.player.velocity.x -= direction * frictionForce;
        } else {
          this.player.velocity.x = 0;
        }
      }
    }
    
    // Apply speed cap based on stamina
    const maxSpeed = PhysicsConfig.movement.maxSpeed * this.player.speedMultiplier;
    if (Math.abs(this.player.velocity.x) > maxSpeed) {
      this.player.velocity.x = Math.sign(this.player.velocity.x) * maxSpeed;
    }
    
    // Update position
    this.player.position.x += this.player.velocity.x * deltaTime;
    this.player.position.y += this.player.velocity.y * deltaTime;
    
    // Check collision with terrain
    this.checkTerrainCollision();
    
    // Check for item collisions
    this.checkItemCollisions();
    
    // Process any scheduled inputs
    this.processScheduledInputs();
    
    // Out of stamina check
    if (this.player.stamina <= 0 && !this.player.crashed) {
      this.player.crashed = true;
      this.player.velocity.x *= 0.1; // Almost stop
      
      // Schedule recovery once stamina is available again
      this.scheduleInput(3000, { action: 'recoverFromCrash' });
    }
  }
  
  update() {
    // Convert frameTime to seconds
    const deltaTime = this.frameTime / 1000;
    
    // Update physics
    this.updatePhysics(deltaTime);
    
    // Update stamina
    this.updateStamina(deltaTime);
    
    // Record state for analysis
    this.stateHistory.push({
      time: this.totalTime,
      position: { ...this.player.position },
      velocity: { ...this.player.velocity },
      onGround: this.player.onGround,
      crashed: this.player.crashed,
      stamina: this.player.stamina,
      segment: this.getTerrainSegmentAtPosition(this.player.position.x),
      score: this.tricks.score
    });
    
    // Update time
    this.totalTime += this.frameTime;
  }
  
  simulateRun(duration) {
    // Schedule some game actions to simulate player input
    this.scheduleInput(2000, { action: 'boost' });
    this.scheduleInput(5000, { action: 'jump' });
    this.scheduleInput(10000, { action: 'boost' });
    this.scheduleInput(15000, { action: 'jump' });
    
    // Run simulation for the specified duration
    let elapsed = 0;
    while (elapsed < duration) {
      this.update();
      elapsed += this.frameTime;
    }
    
    return this.stateHistory;
  }
  
  cleanup() {
    this.resetRandom();
  }
}

describe('Stamina System E2E Full Run Simulation', () => {
  let gameRunner;
  jest.setTimeout(5000); // Increase timeout for this computationally intensive E2E test
  
  beforeEach(() => {
    gameRunner = new GameRunner(42);
  });
  
  afterEach(() => {
    gameRunner.cleanup();
  });
  
  test('stamina stays within valid bounds (0-100) throughout run', measurePerformance(() => {
    // Simulate 30 seconds of gameplay
    const stateHistory = gameRunner.simulateRun(30000);
    
    // Verify stamina stays within valid range
    for (const state of stateHistory) {
      expect(state.stamina).toBeGreaterThanOrEqual(0);
      expect(state.stamina).toBeLessThanOrEqual(100);
    }
  }), 1500);
  
  test('energy items restore stamina as expected', measurePerformance(() => {
    // Run the simulation
    const stateHistory = gameRunner.simulateRun(20000);
    
    // Look for stamina restoration patterns
    let restorationEvents = 0;
    
    for (let i = 1; i < stateHistory.length; i++) {
      const prevStamina = stateHistory[i - 1].stamina;
      const currentStamina = stateHistory[i].stamina;
      
      // If stamina increased significantly, it's likely an item pickup
      if (currentStamina > prevStamina + 5) {
        restorationEvents++;
        
        // Verify the increase is an expected amount (should match one of the item values)
        const increase = currentStamina - prevStamina;
        const expectedAmounts = [15, 30, 50]; // Small, medium, large
        
        // Allow for minor variations due to other factors
        const closeMatch = expectedAmounts.some(expected => 
          Math.abs(increase - expected) < 2
        );
        
        expect(closeMatch).toBe(true);
      }
    }
    
    // Should have had at least some item pickups
    expect(restorationEvents).toBeGreaterThan(0);
  }), 1500);
  
  test('critical stamina affects performance as expected', measurePerformance(() => {
    // Run the simulation with high drain to reach critical state
    const gameRunner = new GameRunner(42);
    
    // Modify terrain to have more high-drain surfaces
    for (const segment of gameRunner.terrain) {
      if (Math.random() > 0.7) {
        segment.surfaceType = 'powder';
      }
    }
    
    const stateHistory = gameRunner.simulateRun(25000);
    
    // Find instances where stamina dropped below critical threshold
    const criticalStates = stateHistory.filter(state => 
      state.stamina <= 20 && !state.crashed
    );
    
    // If we had critical stamina states, verify speed was reduced
    if (criticalStates.length > 0) {
      for (const state of criticalStates) {
        // In critical state, max speed should be reduced
        expect(Math.abs(state.velocity.x)).toBeLessThanOrEqual(15 * 0.7 + 0.1);
      }
      
      // Compare average speed before and during critical state
      const normalStates = stateHistory.filter(state => 
        state.stamina > 20 && !state.crashed && state.onGround
      );
      
      if (normalStates.length > 0 && criticalStates.length > 0) {
        const avgNormalSpeed = normalStates.reduce((sum, state) => 
          sum + Math.abs(state.velocity.x), 0) / normalStates.length;
          
        const avgCriticalSpeed = criticalStates.reduce((sum, state) => 
          sum + Math.abs(state.velocity.x), 0) / criticalStates.length;
          
        // Critical speed should be lower
        expect(avgCriticalSpeed).toBeLessThan(avgNormalSpeed);
      }
    }
    
    gameRunner.cleanup();
  }), 1500);
  
  test('crashes drain stamina and recovery works as expected', measurePerformance(() => {
    // Create an instance with frequent jump features to increase crash likelihood
    const gameRunner = new GameRunner(42);
    
    // Modify terrain to have more jumps
    for (let i = 0; i < gameRunner.terrain.length; i++) {
      if (i % 5 === 0) {
        gameRunner.terrain[i].type = 'jump';
        // Make the landing area steeper to increase crash chance
        if (i < gameRunner.terrain.length - 1) {
          gameRunner.terrain[i + 1].endY = gameRunner.terrain[i + 1].startY + 70;
        }
      }
    }
    
    // Run simulation
    const stateHistory = gameRunner.simulateRun(25000);
    
    // Look for crash events
    let crashes = 0;
    for (let i = 1; i < stateHistory.length; i++) {
      if (!stateHistory[i - 1].crashed && stateHistory[i].crashed) {
        crashes++;
        
        // Stamina should decrease on crash
        expect(stateHistory[i].stamina).toBeLessThan(stateHistory[i - 1].stamina);
        
        // Find recovery after this crash
        let recoveryIndex = -1;
        for (let j = i + 1; j < stateHistory.length; j++) {
          if (stateHistory[j - 1].crashed && !stateHistory[j].crashed) {
            recoveryIndex = j;
            break;
          }
        }
        
        if (recoveryIndex > 0) {
          // After recovery, speed should be reset to a baseline
          expect(stateHistory[recoveryIndex].velocity.x).toBeGreaterThan(0);
        }
      }
    }
    
    // Should have had at least one crash in this modified terrain
    expect(crashes).toBeGreaterThan(0);
    
    gameRunner.cleanup();
  }), 1500);
});
